// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var buildRemoteRequestOptions, commandError, concat, emptySuccess, firstPage, http, isNewPage, markNewPage, markRequestClosed, modifyRequest, newPageOptions, normalizeOptions, openRequests, proxyCommand, proxyRequest, trimHash, url;
  http = require('http');
  url = require('url');
  concat = require('concat-stream');
  buildRemoteRequestOptions = function (request, toPort) {
    var opt, uri;
    uri = url.parse(request.url);
    opt = {
      port: toPort,
      path: uri.path,
      method: request.method,
      headers: request.headers
    };
    opt.headers.connection = 'keep-alive';
    opt.headers['cache-control'] = 'no-store';
    delete opt.headers['if-none-match'];
    delete opt.headers['if-modified-since'];
    return opt;
  };
  trimHash = function (url) {
    return url.split('#')[0];
  };
  normalizeOptions = function (options) {
    options.url = trimHash(options.url);
    return options;
  };
  openRequests = [];
  firstPage = true;
  newPageOptions = {};
  markNewPage = function (options, response) {
    var request;
    newPageOptions = normalizeOptions(options);
    console.log('\n[System] Marking new page request with options: ' + JSON.stringify(newPageOptions));
    openRequests = [];
    return response.end();
  };
  isNewPage = function (url) {
    return url === newPageOptions.url;
  };
  markRequestClosed = function (targetRequest) {
    return openRequests = openRequests.filter(function (request) {
      return request !== targetRequest;
    });
  };
  commandError = function (url, response) {
    console.log('[System] Unknown command: ' + url);
    response.statusCode = 500;
    response.writeHead(response.statusCode, response.headers);
    return response.end();
  };
  emptySuccess = function (response) {
    response.writeHead(200, { 'Content-Type': 'text/html' });
    return response.end();
  };
  proxyCommand = function (url, body, response) {
    switch (url) {
    case '/new-page':
      return markNewPage(body, response);
    default:
      return commandError(url, response);
    }
  };
  modifyRequest = function (request, options) {
    if (!(null != options.headers))
      return;
    return function (accum$) {
      var header, value;
      for (header in options.headers) {
        value = options.headers[header];
        accum$.push(request.headers[header] = value);
      }
      return accum$;
    }.call(this, []);
  };
  proxyRequest = function (request, response, modifyResponse, toPort) {
    var remoteRequest, remoteRequestOptions;
    if (firstPage) {
      firstPage = false;
      console.log('--> ' + request.method + ' ' + request.url + ' (prime the browser)');
      return emptySuccess(response);
    }
    console.log('--> ' + request.method + ' ' + request.url);
    remoteRequestOptions = buildRemoteRequestOptions(request, toPort);
    console.log('    ' + JSON.stringify(remoteRequestOptions));
    if (isNewPage(request.url))
      modifyRequest(remoteRequestOptions, newPageOptions);
    remoteRequest = http.request(remoteRequestOptions, function (remoteResponse) {
      markRequestClosed(remoteRequest);
      if (isNewPage(request.url))
        modifyResponse(remoteResponse);
      response.writeHead(remoteResponse.statusCode, remoteResponse.headers);
      remoteResponse.on('end', function () {
        return console.log('<-- ' + response.statusCode + ' ' + request.url);
      });
      return remoteResponse.pipe(response);
    });
    remoteRequest.on('error', function (error) {
      response.statusCode = 500;
      markRequestClosed(remoteRequest);
      if (isNewPage(request.url))
        modifyResponse(response);
      console.log(error.stack);
      console.log('<-- ' + response.statusCode + ' ' + request.url);
      response.writeHead(response.statusCode, response.headers);
      return response.end();
    });
    openRequests.push(remoteRequest);
    request.pipe(remoteRequest);
    return request.on('end', function () {
      return remoteRequest.end();
    });
  };
  module.exports = function (fromPort, toPort, commandPort, modifyResponse) {
    var commandServer, server;
    server = http.createServer(function (request, response) {
      return proxyRequest(request, response, modifyResponse, toPort);
    });
    server.listen(fromPort);
    console.log('Listening on port ' + fromPort + ' and proxying to ' + toPort + '.');
    commandServer = http.createServer(function (request, response) {
      return request.pipe(concat(function (body) {
        var options;
        if (null != body)
          options = JSON.parse(body.toString());
        return proxyCommand(request.url, options, response);
      }));
    });
    commandServer.listen(commandPort);
    return console.log('Listening for commands on port ' + commandPort + '.');
  };
}.call(this);
